rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Users collection - users can read any profile, update only their own
    // Document ID is now username (not authUid), so we check authUid field instead
    // Exception: Allow updating another user's friends array when accepting a friend request
    match /users/{username} {
      allow read: if request.auth != null;
      
      // Allow create: user can create their own document if authUid matches
      allow create: if request.auth != null && 
        request.resource.data.authUid == request.auth.uid;
      
      // Allow update: user can update their own document if authUid matches
      // OR if updating another user's friends array (for friend requests)
      allow update: if request.auth != null && (
        // User updating their own document (authUid must match)
        (request.resource.data.authUid == request.auth.uid && 
         (!resource.exists || resource.data.authUid == request.auth.uid)) ||
        // OR allowing another user to update friends array (for accepting friend requests)
        (resource.exists &&
         request.resource.data.authUid != request.auth.uid &&
         // Ensure authUid field doesn't change (user ID should remain the same)
         request.resource.data.authUid == resource.data.authUid &&
         // Only allow modifying friends and updatedAt fields for friend requests
         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['friends', 'updatedAt']))
      );
      
      // Allow delete: user can delete their own document
      allow delete: if request.auth != null && 
        resource.data.authUid == request.auth.uid;
      
      // Notifications subcollection - users can only read/update their own notifications
      // username is the parent document ID, check parent user's authUid field to verify ownership
      match /notifications/{notificationId} {
        allow read: if request.auth != null && 
          get(/databases/$(database)/documents/users/$(username)).data.authUid == request.auth.uid;
        allow create: if request.auth != null; // Anyone can create notifications for this user
        allow update: if request.auth != null && 
          get(/databases/$(database)/documents/users/$(username)).data.authUid == request.auth.uid;
        allow delete: if request.auth != null && 
          get(/databases/$(database)/documents/users/$(username)).data.authUid == request.auth.uid;
      }
    }
    
    // Friend Requests collection
    // Rules per requirements:
    // - create: allowed iff request.auth.uid == request.resource.data.fromUserId and toUserId != fromUserId and status == 'pending'
    // - read: allowed if caller is sender or receiver
    // - update/delete: allowed if receiver changes only status (accept/decline), or sender cancels/deletes while status == 'pending'
    match /friendRequests/{requestId} {
      // Read: allowed if caller is sender or receiver
      // For queries, this works because Firestore evaluates the rule for each matching document
      allow read: if request.auth != null && (
        resource == null || // Allow query evaluation (resource is null during query planning)
        resource.data.fromUserId == request.auth.uid ||
        resource.data.toUserId == request.auth.uid
      );
      
      // Create: allowed iff request.auth.uid == request.resource.data.fromUserId 
      // and toUserId != fromUserId and status == 'pending'
      allow create: if request.auth != null && 
        request.resource.data.fromUserId == request.auth.uid &&
        request.resource.data.toUserId != request.auth.uid &&
        request.resource.data.status == 'pending';
      
      // Update: allowed if receiver changes only status (accept/decline), 
      // or sender cancels while status == 'pending'
      allow update: if request.auth != null && (
        // Receiver can update status (accept/decline)
        (resource.data.toUserId == request.auth.uid) ||
        // Sender can cancel while status == 'pending'
        (resource.data.fromUserId == request.auth.uid && 
         resource.data.status == 'pending')
      );
      
      // Delete: allowed if receiver deletes, or sender deletes while status == 'pending'
      allow delete: if request.auth != null && (
        resource.data.toUserId == request.auth.uid ||
        (resource.data.fromUserId == request.auth.uid && 
         resource.data.status == 'pending')
      );
    }
    
    // Usernames collection - for username reservation
    match /usernames/{username} {
      allow read: if request.auth != null;
      allow write: if request.auth != null;
    }
    
    // Posts collection - users can read public posts, write their own
    match /posts/{postId} {
      allow read: if request.auth != null;
      allow write: if request.auth != null && request.resource.data.userId == request.auth.uid;
      
      // Comments subcollection - users can read all comments, write their own
      match /comments/{commentId} {
        allow read: if request.auth != null;
        allow create: if request.auth != null && request.resource.data.userId == request.auth.uid;
        allow delete: if request.auth != null && resource.data.userId == request.auth.uid;
      }
    }
    
    // Groups collection
    match /groups/{groupId} {
      allow read: if request.auth != null;
      allow write: if request.auth != null;
    }
    
    // Votes collection - location-based public voting for "tonight" polls
    // Anyone can read votes (public), users can vote once per location per day
    match /votes/{voteId} {
      allow read: if request.auth != null; // Public votes - anyone authenticated can read
      allow create: if request.auth != null && 
        request.resource.data.userId == request.auth.uid; // Users can only vote as themselves
      allow update: if request.auth != null && 
        resource.data.userId == request.auth.uid && // Users can only update their own votes
        request.resource.data.userId == resource.data.userId; // Ensure userId doesn't change
      allow delete: if request.auth != null && 
        resource.data.userId == request.auth.uid; // Users can delete their own votes
    }
  }
}

