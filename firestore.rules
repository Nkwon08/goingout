rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Users collection - users can read any profile, update only their own
    // Document ID is now username (not authUid), so we check authUid field instead
    // Exception: Allow updating another user's friends array when accepting a friend request
    match /users/{username} {
      allow read: if request.auth != null;
      
      // Allow create: user can create their own document if authUid matches
      allow create: if request.auth != null && 
        request.resource.data.authUid == request.auth.uid;
      
      // Allow update: user can update their own document OR update another user's friends array
      // when accepting a friend request (for mutual friend addition)
      allow update: if request.auth != null && (
        // User can update their own document (authUid must match)
        (request.resource.data.authUid == request.auth.uid && 
         (!resource.exists || resource.data.authUid == request.auth.uid)) ||
        // OR user can update another user's friends array (for mutual friend addition)
        // This allows adding the current user's username to another user's friends list
        // Only allow if: authUid is not changed (ensures we're not modifying sensitive user data)
        (request.resource.data.authUid == resource.data.authUid &&
         resource.data.authUid != request.auth.uid)
      );
      
      // Allow delete: user can delete their own document
      allow delete: if request.auth != null && 
        resource.data.authUid == request.auth.uid;
      
      // Notifications subcollection - users can only read/update their own notifications
      // username is the parent document ID, check parent user's authUid field to verify ownership
      match /notifications/{notificationId} {
        allow read: if request.auth != null && 
          get(/databases/$(database)/documents/users/$(username)).data.authUid == request.auth.uid;
        allow create: if request.auth != null; // Anyone can create notifications for this user
        allow update: if request.auth != null && 
          get(/databases/$(database)/documents/users/$(username)).data.authUid == request.auth.uid;
        allow delete: if request.auth != null && 
          get(/databases/$(database)/documents/users/$(username)).data.authUid == request.auth.uid;
      }
    }
    
    // Friend Requests collection
    // Rules per requirements:
    // - create: allowed iff request.auth.uid == request.resource.data.fromUserId and toUserId != fromUserId and status == 'pending'
    // - read: allowed if caller is sender or receiver
    // - update/delete: allowed if receiver changes only status (accept/decline), or sender cancels/deletes while status == 'pending'
    match /friendRequests/{requestId} {
      // Read: allowed if caller is sender or receiver
      // For queries, this works because Firestore evaluates the rule for each matching document
      allow read: if request.auth != null && (
        resource == null || // Allow query evaluation (resource is null during query planning)
        resource.data.fromUserId == request.auth.uid ||
        resource.data.toUserId == request.auth.uid
      );
      
      // Create: allowed iff request.auth.uid == request.resource.data.fromUserId 
      // and toUserId != fromUserId and status == 'pending'
      allow create: if request.auth != null && 
        request.resource.data.fromUserId == request.auth.uid &&
        request.resource.data.toUserId != request.auth.uid &&
        request.resource.data.status == 'pending';
      
      // Update: allowed if receiver changes only status (accept/decline), 
      // or sender cancels while status == 'pending'
      allow update: if request.auth != null && (
        // Receiver can update status to 'accepted' or 'declined'
        (resource.data.toUserId == request.auth.uid &&
         (request.resource.data.status == 'accepted' || request.resource.data.status == 'declined') &&
         request.resource.data.fromUserId == resource.data.fromUserId &&
         request.resource.data.toUserId == resource.data.toUserId) ||
        // Sender can cancel while status == 'pending' (change status to 'cancelled')
        (resource.data.fromUserId == request.auth.uid && 
         resource.data.status == 'pending' &&
         request.resource.data.status == 'cancelled')
      );
      
      // Delete: allowed if receiver deletes, or sender deletes while status == 'pending'
      allow delete: if request.auth != null && (
        resource.data.toUserId == request.auth.uid ||
        (resource.data.fromUserId == request.auth.uid && 
         resource.data.status == 'pending')
      );
    }
    
    // Usernames collection - for username reservation
    match /usernames/{username} {
      allow read: if request.auth != null;
      allow write: if request.auth != null;
    }
    
    // Posts collection - users can read public posts, write their own
    match /posts/{postId} {
      allow read: if request.auth != null;
      allow write: if request.auth != null && request.resource.data.userId == request.auth.uid;
      
      // Comments subcollection - users can read all comments, write their own
      match /comments/{commentId} {
        allow read: if request.auth != null;
        allow create: if request.auth != null && request.resource.data.userId == request.auth.uid;
        allow delete: if request.auth != null && resource.data.userId == request.auth.uid;
      }
    }
    
    // Groups collection
    match /groups/{groupId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null;
      allow update: if request.auth != null;
      allow delete: if request.auth != null && 
        resource.data.creator == request.auth.uid; // Only the creator can delete the group
      
      // Messages subcollection - all group members can read and write
      match /messages/{messageId} {
        allow read: if request.auth != null;
        allow create: if request.auth != null && 
          request.resource.data.userId == request.auth.uid;
        allow update: if false; // Messages cannot be updated
        allow delete: if request.auth != null && (
          resource.data.userId == request.auth.uid || // Users can delete their own messages
          get(/databases/$(database)/documents/groups/$(groupId)).data.creator == request.auth.uid // Group creator can delete any message
        );
      }
      
      // Locations subcollection - group members can share their location
      match /locations/{userId} {
        allow read: if request.auth != null; // All group members can see locations
        allow create: if request.auth != null && 
          request.resource.data.userId == request.auth.uid; // Users can only share their own location
        allow update: if request.auth != null && 
          resource.data.userId == request.auth.uid; // Users can only update their own location
        allow delete: if request.auth != null && (
          resource.data.userId == request.auth.uid || // Users can stop sharing their location
          get(/databases/$(database)/documents/groups/$(groupId)).data.creator == request.auth.uid // Group creator can delete any location
        );
      }
      
      // Polls subcollection - group members can create and vote on polls
      match /polls/{pollId} {
        allow read: if request.auth != null; // All group members can read polls
        allow create: if request.auth != null && 
          request.resource.data.creatorId == request.auth.uid; // Users can only create polls as themselves
        allow update: if request.auth != null; // All group members can vote (update polls)
        allow delete: if request.auth != null && (
          resource.data.creatorId == request.auth.uid || // Poll creator can delete their own poll
          get(/databases/$(database)/documents/groups/$(groupId)).data.creator == request.auth.uid // Group creator can delete any poll
        );
      }
    }
    
    // Votes collection - location-based public voting for "tonight" polls
    // Anyone can read votes (public), users can vote once per location per day
    match /votes/{voteId} {
      allow read: if request.auth != null; // Public votes - anyone authenticated can read
      allow create: if request.auth != null && 
        request.resource.data.userId == request.auth.uid; // Users can only vote as themselves
      allow update: if request.auth != null && 
        resource.data.userId == request.auth.uid && // Users can only update their own votes
        request.resource.data.userId == resource.data.userId; // Ensure userId doesn't change
      allow delete: if request.auth != null && 
        resource.data.userId == request.auth.uid; // Users can delete their own votes
    }
  }
}